# 今回のテーマ

- 演算子とはなにか
- 演算子の種類
- 演算の方法
- 演算子の優先順位

# 演算子とはなにか

演算子とは、プログラムで計算を行うために使用する記号のこと。

# 演算子の種類

演算子には、以下のような種類がある。

- 算術演算子
- 代入演算子
- 比較演算子
- 論理演算子
- ビット演算子

## 算術演算子

算術演算子は、以下のものがある。

| 演算子 | 名前 |  記述例  |       意味       |
|:---:|:--:|:-----:|:--------------:|
|  +  | 加算 | a + b |    aとbを加算する    |
|  -  | 減算 | a - b |   aからbを減算する    |
|  *  | 乗算 | a * b |    aとbを乗算する    |
|  /  | 除算 | a / b |    aをbで除算する    |
|  %  | 剰余 | a % b | aをbで除算した余りを求める |

### 演算結果を変数に代入する

演算結果を変数に代入する場合は、以下のように記述する。

```c
#include <stdio.h>

int main(void)
{
    int a = 10;
    int b = 20;
    int c = 0;

    c = a + b;
    printf("c = %d\n", c);

    return 0;
}
```

## インクリメント演算子とデクリメント演算子

インクリメント演算子とデクリメント演算子は、1のみ増減する演算子である。

```c
int var1 = 8;
int var2 = 7;

var1++;
printf("var1 = %d\n", var1);

var2--;
printf("var2 = %d\n", var2);
```

この例では、`var1`は1増加させた`9`が出力され、`var2`は1減少させた`6`が出力される。

#### インクリメント演算子とデクリメント演算子の位置

インクリメント演算子とデクリメント演算子は、変数の前後に記述することができる。

```c
int var1 = 8;
int var2 = 7;

var1++;
printf("var1 = %d\n", var1);

++var2;
printf("var2 = %d\n", var2);
```

前置きも後ろ置きも、同じ結果が得られる。
しかし、前置きの場合は、演算子の処理が先に行われる。

```c

int var1 = 8;
int var2 = 0
        
var2 = ++var1;
```

サンプルコードのような例では、`var1`の値が先に`9`になり、その後`var2`に代入される。
しかし、これを後置きにすると、`var2`に代入されるのは`8`になる。

```c
int var1 = 8;
int var2 = 0
        
var2 = var1++;
```

代入されてから、`var1`の値が増加するためである。

## 代入演算子

代入演算子はここまでよく使ってきた`=`がそれにあたる。

```c
int var1 = 8;
```

このように、変数に値を代入する際に使用する。

### 代入演算子と算術演算子の組み合わせ

代入演算子と算術演算子を組み合わせることができる。

| 演算子 |  記述例   |    意味     |
|:---:|:------:|:---------:|
| +=  | a += b | a = a + b |
| -=  | a -= b | a = a - b |
| *=  | a *= b | a = a * b |
| /=  | a /= b | a = a / b |
| %=  | a %= b | a = a % b |

## ビット演算子

ビット演算子とは整数型の数値に対してビット単位で演算を行うときに使用する演算子。
例えば10進数での7を2進数で表現すると0000000000000111となる。
このように2進数で表現された数値に対してビット演算を行うことができる。

| 演算子 |      記述例      |      意味       |
|:---:|:-------------:|:-------------:|
|  &  | a = b & 0x4F  |      論理積      |
| \|  | a = b \| 0x0F |      論理和      |
|  ^  | 	a = b ^ 0xFF |    排他的論理和     |
|  ~  |      ~a       |  aのビット反転を求める  |
| <<  |  	a = a << 2  | aのビットを左にシフトする |
| >>  |  	a = a >> 2  | aのビットを右にシフトする |

### ビット論理積

論理積は AND 演算とも呼ばれる。
両方のビットが 1 の場合に 1 を返す演算子。

:::note
0000000000001011  = 11
0000000000001110  = 14
----------------
0000000000001010  = 10
:::

上記では 11(0x000B) と 14(0x000E) の AND を取ると 10(0x000A) となる。実際には以下のように記述をする
```c
short int a = 0x000B;
a = a & 0x000E;
```

上記の演算の結果、変数 a には 10(0x000A) が格納されることになる。

### ビット論理和

論理和は OR 演算とも呼ばれる。
どちらかのビットが 1 の場合に 1 を返す演算子。

:::note
0000000000001011  = 11
0000000000001110  = 14
----------------
0000000000001111  = 15
:::

上記では 11(0x000B) と 14(0x000E) の OR を取ると 15(0x000F) となる。実際には以下のように記述をする
```c
short int a = 0x000B;
a = a | 0x000E;
```

上記の演算の結果、変数 a には 15(0x000F) が格納されることになる。

### ビット排他的論理和

排他的論理和は XOR 演算とも呼ばれる。
どちらか一方のビットが 1 の場合に 1 を返す演算子。

:::note
0000000000001011  = 11
0000000000001110  = 14
----------------
0000000000000101  = 5
:::

上記では 11(0x000B) と 14(0x000E) の XOR を取ると 5(0x0005) となる。実際には以下のように記述をする
```c
short int a = 0x000B;
a = a ^ 0x000E;
```

上記の演算の結果、変数 a には 5(0x0005) が格納されることになる。

### ビット反転

ビット反転は NOT 演算とも呼ばれる。
ビットの反転を行う演算子。

:::note
0000000000001011  = 11
----------------
1111111111110100  = -12
:::

※short int 型の値を 2 進数で 2 の補数表現で行った場合、最上位ビットが 1 の値は負の数となる。

上記では 11(0x000B) の NOT を取ると -12(0xFFF4) となる。実際には以下のように記述をする
```c
short int a = 0x000B;
a = ~a;
```

上記の演算の結果、変数 a には -12(0xFFF4) が格納されることになる。

### ビットシフト演算

ビットシフト演算は、ビットを左右にシフトする演算子。

:::note
0000000000001011  = 11
----------------
0000000000101100  = 44
:::

上記では 11(0x000B) を左に 2 ビットシフトすると 44(0x002C) となる。実際には以下のように記述をする
```c
short int a = 0x000B;
a = a << 2;
```

上記の演算の結果、変数 a には 44(0x002C) が格納されることになる。
44は11の4倍である。左シフトは2の累乗の掛け算と同じである。

:::note
0000000000001011  = 11
----------------
0000000000000010  = 2
:::

上記では 11(0x000B) を右に 2 ビットシフトすると 2(0x0002) となる。実際には以下のように記述をする
```c
short int a = 0x000B;
a = a >> 2;
```

上記の演算の結果、変数 a には 2(0x0002) が格納されることになる。
2は11の4分の1である。右シフトは2の累乗の割り算と同じである。

### ビットシフト演算の注意点

負の数に対して右シフトを行った結果がどうなるのかは処理系によって異なる。プログラムが同じでも処理系によって結果が異なる可能性がありますので、負の数に対して右シフトはあまり行わない方がいいかもしれない。
いくつか対策があるようだが今回は割愛する。

# 演算子の優先順位

演算子には、優先順位がある。

```c
#include <stdio.h>

int main(void)
{
    int a = 10;
    int b = 20;
    int c = 0;

    c = a + b * 2;
    printf("c = %d\n", c);

    return 0;
}
```

上記の場合、`b * 2`が先に計算される。

| 優先順位 |                演算子                 | 
|:----:|:----------------------------------:|
|  1   |             () [] -> .             |
|  2   |    ! ~ ++ -- + - * & (型) sizeof    |
|  3   |               * / %                |
|  4   |                + -                 |
|  5   |               << >>                |
|  6   |             < <= > >=              |
|  7   |               == !=                |
|  8   |                 &                  |
|  9   |                 ^                  |
|  10  |                 \|                 |
|  11  |                 &&                 |
|  12  |                \|\|                |
|  13  |                 ?:                 |
|  14  | = += -= *= /= %= <<= >>= &= ^= \|= |
|  15  |                 ,                  |

## 演算子の優先順位を変更する

演算子の優先順位を変更するには、()を使用する。

```c
  int a = 10;
  int b = 20;
  int c = 0;
  c = (a + b) * 2;
}
```

`()`がなければ、`b * 2`が先に計算されるが、`()`があるので、`a + b`が先に計算される。

# まとめ

演算子は四則計算を始めとした様々な計算を行うことができる。
演算子には優先順位がある。
計算の順番を変更することができる。